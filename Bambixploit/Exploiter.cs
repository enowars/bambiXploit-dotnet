namespace Bambixploit
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;
    using RunProcessAsTask;

    public class Exploiter
    {
        private static readonly HttpClient HttpClient = new HttpClient();
        private readonly Configuration settings;
        private readonly Submitter submitter;
        private readonly Storage storage;
        private long pwnRound = 0;

        public Exploiter(Configuration settings, Submitter submitter, Storage storage)
        {
            this.settings = settings;
            this.submitter = submitter;
            this.storage = storage;
        }

        public void Start()
        {
            Task.Run(this.Run);
        }

        private async void Run()
        {
            while (true)
            {
                try
                {
                    var targetsFile = await (await HttpClient.GetAsync(this.settings.TargetsUrl)).Content.ReadAsStringAsync();
                    var targets = targetsFile.Split('\n');
                    var delay = this.settings.Interval * 1000 / targets.Length;
                    foreach (var target in targets)
                    {
                        var exploitTask = Task.Run(async () => await this.Exploit(target, this.pwnRound));
                        await Task.Delay(delay);
                    }

                    this.pwnRound += 1;
                    this.storage.LatestRound = this.pwnRound;
                }
                catch (Exception e)
                {
                    Console.WriteLine(e);
                    await Task.Delay(1000);
                }
            }
        }

        private async Task Exploit(string target, long pwnRound)
        {
            using var cancelSource = new CancellationTokenSource(this.settings.Interval * 1000);
            var psi = new ProcessStartInfo(this.settings.Command, this.settings.Arguments + " " + target);
            var stdout = new List<string>();
            var stderr = new List<string>();
            ProcessResults? result;
            try
            {
                result = await ProcessEx.RunAsync(psi, stdout, stderr, cancelSource.Token);
            }
            catch (Exception e)
            {
                Console.WriteLine($"{e.Message}\n{e.StackTrace}");
            }
            finally
            {
                foreach (var line in stdout)
                {
                    var flags = this.settings.FlagRegex.Matches(line)
                        .Select(m => m.Value)
                        .ToArray();

                    if (flags != null)
                    {
                        foreach (var flag in flags)
                        {
                            await this.submitter.Enqueue(flag);
                        }
                    }
                }

                await this.storage.SaveLogs(stdout, stderr, pwnRound, target);
            }
        }
    }
}
